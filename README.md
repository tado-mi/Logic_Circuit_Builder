# showing off:

**author:** Lusine Keshishyan / tado-mi

**date:**   12 Dec 2017

**use:**    free. credit when due is encouraged and appreciated

# general

the purpose of the code is to take as an input a logic expression in English, such as *x and not y* and evaluate it with all the possible truth assignments. It supports up to 3 variables and all 5 logic gates: *or, and, not, nor, nand*. 

## high-level description of the 'algorithm'

* convert the expression into a postfix (using [Shanting-Yard algorithm](https://en.wikipedia.org/wiki/Shunting_yard_algorithm)), treating logic operations as arithmetic operations:

        +       or
        -       nor
        *       and
        /       nand
        !       not

operations are chosen in order to correspond to desired binding of the logic operators (ie: precedence of the the arithmetic operations) and their functions are hardcoded to fit our purposes.

* build the circuit

the circuit is essentially the expression tree of the obtained postfix operation, built according to a standard procedure, more on which you could read [here](https://stackoverflow.com/questions/423898/postfix-notation-to-expression-tree).

* generate truth assignments

are generated by "counting in binary" up to 2<sup>n</sup>, where n is the number of unique variables.

**note:** for n > 0 variables there exist 2<sup>n</sup> possible truth assignments, and each assignment can be represented by a number m in binary < 2<sup>n</sup>. For example, if n = 1, m = {0, 1} and one-variable expression can have 2 possible assignments: x = F (represented by 0) or x = T (represented by 1). Similarly, if n = 2, m = {0, 1, 2, 3} = {00, 01, 10, 11}, which correspond to all possible truth assignments of an expression with 2 variables.

* assign truth assignment

each unique variable in the expression tree is linked to its instances. For example, if we have *not x or x*, the tree looks like this:

                +
            /       \
           !         |
           |         |
           x         x      // instances of x
            \       /
                x           // the unique variable x
                
switch (flipping the assignment from 1 to 0 / on/off / true/false) occurs at the unique variable and is past on to instances.

* evaluation

evaluation happens from root to leaves, recursively.

# included files:

## functions.c

bunch of helping function because, some of which (string_legth, power) come with C, the rest are specific to current package.

## stack.c

a simple implementation of the [stack](https://en.wikipedia.org/wiki/Stack_%28abstract_data_types%29) data structure with its data type hardcoded as a string.

## main.c

for each provided case, main() calls the run(expression, assgn) function, which calculates the postfix of the given expression and either tests the assignment or loops through is all possible truth assignments.

**evaluate(char\* post, char\* assign):** simply builds the circuit from postfix and sets the variables to the given assignment.

**count(int i, int length, char\* var_names):** implicitly converts i to binary and returns the truth assignment corresponding to i. *length* and *var_name* are used to format answer in a human-friendly way.

## postfix.c
simple implementation of Shanting-Yard algorithm. Comments added where non trivial modifications have been made.

## circuit.c
implementation of a data structure suspiciously resembling a [binary tree](), where logic gates are treated as internal nodes and variables are treated as leaves. Note that operation *not* takes only one argument: so, intenral nodes corresponding to a *not* gate have only a right child.

**build(char\* post):** builds a circuit from a postfix of a logic expression much like an arithmetic expression tree would have been built from a postfix of an arithmetic expression.

**set_switch(circuit c, circuit\* input):** input is the assignment of values to the variables in the circuit c. The function recurcively locates the variables and sets the switch on or off (ie: 0 or 1)

**create_switch(char\* assign, int n):** simply parses a string of form "x: T; y: F" to an array of one-node circuits with information of what the ith value should be, that will be later fed into set_switch() function

**eval_circ(circuit c):** recurisve evaluation of the circuit, starting at the "root" (which would be the last set gate) and tracing down to leaves, assungi that switches are already created and set

### circuit_stack.c

a simple implementation of the [stack](https://en.wikipedia.org/wiki/Stack_%28abstract_data_types%29) data structure with its data type hardcoded as a circuit, where circuit is a data structure included in the package.

# compiling

hit on the terminal

	make
	make run
	make clean

equivalent to:

	gcc main.c -o main
	./main
	rm main

# note

* I am using **==** and **!=** for string comparison, which is not exactly a good practice. However, it is working out for this particular task and keeps code lighter on the eye
* It is possible that your gcc compiler will throw a seg fault streight away (although it is fine on gcc that comes with ubuntu 17.10). I would look to increase the allocated memories.
